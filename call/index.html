<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/x86reference/styles.9b3fd289762fc3c991dd.css" data-identity="gatsby-global-css">@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap);.search{position:relative}.search input{border:2px solid #ccc;border-radius:4px;display:block;outline:0;padding:7px 12px 6px;transition:border-color .25s ease-out;width:100%}.search input:focus{border-color:var(--link-color)}.search input::-moz-placeholder{color:#ccc}.search input:-ms-input-placeholder{color:#ccc}.search input::placeholder{color:#ccc}.search ul{background:#fff;border-radius:4px;box-shadow:var(--floating-shadow);left:0;max-height:400px;opacity:1;overflow-y:scroll;pointer-events:auto;position:absolute;top:calc(100% + 2px);transition:opacity .25s ease-out;width:550px;z-index:1000}.search ul.hidden{opacity:0;pointer-events:none}.search ul>li>a{color:#000;display:block;padding:.5rem;text-decoration:none}.search ul>li.hover>a,.search ul>li>a:hover{background:var(--link-color);color:#fff}@media screen and (max-width:768px){.search ul{max-height:10000px;width:100%}}.footer{font-size:.85rem;text-align:center}.footer>.copyright{font-size:.75rem;margin-top:.35rem;opacity:.5}#sidebar{background:var(--sidebar-background);display:flex;flex-direction:column;height:100vh;padding:var(--sidebar-padding);position:absolute;width:var(--sidebar-width)}#sidebar>section:not(:last-child){padding-bottom:1rem}#sidebar>section:last-child{margin-top:auto}#site-title{align-items:flex-end;display:flex;flex-direction:row;font-size:1.5rem;justify-content:space-between;margin:1rem 0 .25rem}#site-title>img{margin-bottom:.5rem;width:64px}#site-description{font-size:.9rem}#site-description>p{color:#555;margin-top:.2rem}@media screen and (max-width:768px){#sidebar{display:flex;flex-direction:column;height:auto;position:relative;width:100vw}}

/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{-webkit-text-size-adjust:100%;line-height:1.15}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}:root{--font-size:16px;--font-w-medium:400;--font-w-bold:700;--font-family:"Roboto",sans-serif;--sidebar-width:340px;--sidebar-padding:1rem;--sidebar-background:#eee;--body-padding:1.5rem;--link-color:#007eff;--floating-shadow:hsla(210,8%,62%,0.2) 0px 8px 24px}*{box-sizing:border-box}a:not(.button,.no-underline){border-bottom:2px solid transparent;color:var(--link-color);text-decoration:none;transition:border-bottom-color .1s ease-out}a:not(.button,.no-underline):hover{border-bottom-color:var(--link-color)}h1{font-size:2rem;margin:0 0 1rem}h1,h2{font-weight:700}h2{font-size:1.5rem;margin:1rem 0 .5rem}p,ul{margin:0}ul{list-style:none;padding:0}#root{font-family:var(--font-family);font-size:var(--font-size);height:100vh;width:100vw}#main{height:100%;overflow-y:auto;padding:var(--body-padding);padding-left:calc(var(--sidebar-width) + var(--body-padding));width:100%}@media screen and (min-width:769px){.hidden-desktop{display:none}}@media screen and (max-width:768px){.hidden-mobile{display:none}#main{height:auto;padding-left:var(--body-padding)}}:root{--button-text:#333;--button-background:#49ffa2;--button-background-hover:#62ffaf}.button{background:var(--button-background);border:0;border-radius:4px;color:var(--button-text);cursor:pointer;font-weight:700;padding:5px 12px 4px;text-decoration:none;transform:scale(1);transition:all 50ms ease-out}.button:active,.button:hover{background:var(--button-background-hover);box-shadow:var(--floating-shadow);transform:scale(1.03)}.button svg{stroke:currentColor;margin-left:.5rem;vertical-align:top;width:16px}.op-title{align-items:flex-start;display:flex;flex-direction:row;justify-content:space-between}.op-title>h1{margin:0}.op-variants>ul{list-style:disc;padding-left:1.5rem}.op-variants>ul>li{color:var(--link-color);font-weight:var(--font-w-bold)}.op-documentation>article{line-height:1.4;max-width:800px;text-align:justify}.op-documentation>article>p{margin-bottom:.7rem}</style><meta name="generator" content="Gatsby 3.14.2"/><title data-react-helmet="true">call | x86reference</title><meta data-react-helmet="true" name="description" content="Quickly search x86 assembly documentation."/><meta data-react-helmet="true" property="og:title" content="call"/><meta data-react-helmet="true" property="og:description" content="Quickly search x86 assembly documentation."/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="superhawk610"/><meta data-react-helmet="true" name="twitter:title" content="call"/><meta data-react-helmet="true" name="twitter:description" content="Quickly search x86 assembly documentation."/><link as="script" rel="preload" href="/x86reference/webpack-runtime-a3295d5c46c6b58c034e.js"/><link as="script" rel="preload" href="/x86reference/framework-240c1f9815d126e19dd9.js"/><link as="script" rel="preload" href="/x86reference/app-78307e57dfe1c5aac904.js"/><link as="script" rel="preload" href="/x86reference/commons-c101e594ad3faaaa90f4.js"/><link as="script" rel="preload" href="/x86reference/component---src-templates-op-tsx-e0141dc34b70c1c1eef2.js"/><link as="fetch" rel="preload" href="/x86reference/page-data/call/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/x86reference/page-data/sq/d/2451724630.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/x86reference/page-data/sq/d/3830446752.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/x86reference/page-data/sq/d/63159454.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/x86reference/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div id="root"><nav id="sidebar"><section><div id="site-title"><a href="/x86reference/">x86reference</a><img src="data:image/png;base64,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"/></div><div id="site-description"><p>Quickly search x86 assembly documentation.</p><p>powered by<!-- --> <a href="https://github.com/zneak/x86doc" target="_blank">zneak/x86doc</a></p></div></section><section><div class="search"><div role="combobox" aria-expanded="false" aria-haspopup="listbox" aria-labelledby="downshift-50-label"><input aria-autocomplete="list" aria-labelledby="downshift-50-label" autoComplete="off" value="" id="downshift-50-input" placeholder="Search..."/></div><ul role="listbox" aria-labelledby="downshift-50-label" id="downshift-50-menu" class="hidden"></ul></div></section><section class="hidden-mobile"><footer class="footer"><p>created by<!-- --> <a href="https://github.com/superhawk610" target="_blank">superhawk610</a> <!-- -->· <a href="https://github.com/superhawk610/x86reference">repo</a></p><p class="copyright">© <!-- -->2021<!-- -->, all rights reserved</p></footer></section></nav><main id="main"><div id="scroll-wrapper"><div class="op-title"><h1>call</h1><a class="button" href="https://www.felixcloutier.com/x86/CALL.html" target="_blank" rel="noreferrer noopener">Full Documentation<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="up-right-from-square" class="svg-inline--fa fa-up-right-from-square" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M384 320c-17.67 0-32 14.33-32 32v96H64V160h96c17.67 0 32-14.32 32-32s-14.33-32-32-32L64 96c-35.35 0-64 28.65-64 64V448c0 35.34 28.65 64 64 64h288c35.35 0 64-28.66 64-64v-96C416 334.3 401.7 320 384 320zM488 0H352c-12.94 0-24.62 7.797-29.56 19.75c-4.969 11.97-2.219 25.72 6.938 34.88L370.8 96L169.4 297.4c-12.5 12.5-12.5 32.75 0 45.25C175.6 348.9 183.8 352 192 352s16.38-3.125 22.62-9.375L416 141.3l41.38 41.38c9.156 9.141 22.88 11.84 34.88 6.938C504.2 184.6 512 172.9 512 160V24C512 10.74 501.3 0 488 0z"></path></svg></a></div><section class="op-variants"><h2>Variants</h2><ul><li>CALL</li></ul></section><section class="op-documentation"><h2>Documentation</h2><article><p>Saves procedure linking information on the stack and branches to the called procedure specified using the target operand. The target operand specifies the address of the first instruction in the called procedure. The operand can be an immediate value, a general-purpose register, or a memory location.</p><p>This instruction can be used to execute four types of calls:</p><p>The latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode. See “Calling Procedures Using Call and RET” in Chapter 6 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for additional information on near, far, and inter-privilege-level calls. See Chapter 7, “Task Management,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for information on performing task switches with the CALL instruction.</p><p><strong>Near Call.</strong> When executing a near call, the processor pushes the value of the EIP register (which contains the offset of the instruction following the CALL instruction) on the stack (for use later as a return-instruction pointer). The processor then branches to the address in the current code segment specified by the target operand. The target operand specifies either an absolute offset in the code segment (an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register; this value points to the instruction following the CALL instruction). The CS register is not changed on near calls.</p><p>For a near call absolute, an absolute offset is specified indirectly in a general-purpose register or a memory location (<em>r/m16</em>, <em>r/m32, or r/m64</em>). The operand-size attribute determines the size of the target operand (16, 32 or 64 bits). When in 64-bit mode, the operand size for near call (and all near branches) is forced to 64-bits. Absolute offsets are loaded directly into the EIP(RIP) register. If the operand size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits. When accessing an absolute offset indirectly using the stack pointer [ESP] as the base register, the base value used is the value of the ESP before the instruction executes.</p><p>A relative offset (<em>rel16</em> or <em>rel32</em>) is generally specified as a label in assembly code. But at the machine code level, it is encoded as a signed, 16- or 32-bit immediate value. This value is added to the value in the EIP(RIP) register. In 64-bit mode the relative offset is always a 32-bit immediate value which is sign extended to 64-bits before it is added to the value in the RIP register for the target calculation. As with absolute offsets, the operand-size attribute determines the size of the target operand (16, 32, or 64 bits). In 64-bit mode the target operand will always be 64-bits because the operand size is forced to 64-bits for near branches.</p><p><strong>Far Calls in Real-Address or Virtual-8086 Mode.</strong> When executing a far call in real- address or virtual-8086 mode, the processor pushes the current value of both the CS and EIP registers on the stack for use as a return-instruction pointer. The processor then performs a “far branch” to the code segment and offset specified with the target operand for the called procedure. The target operand specifies an absolute far address either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). With the pointer method, the segment and offset of the called procedure is encoded in the instruction using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.</p><p><strong>Far Calls in Protected Mode.</strong> When the processor is operating in protected mode, the CALL instruction can be used to perform the following types of far calls:</p><p>In protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of call operation to be performed.</p><p>If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). The operand- size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register; the offset from the instruction is loaded into the EIP register.</p><p>A call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making calls between 16-bit and 32-bit code segments.</p><p>When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a call gate. The segment selector specified by the target operand identifies the call gate. The target operand can specify the call gate segment selector either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)</p><p>On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, no stack switch occurs.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack, an optional set of parameters from the calling procedures stack, and the segment selector and instruction pointer for the calling procedure’s code segment. (A value in the call gate descriptor determines how many parameters to copy to the new stack.) Finally, the processor branches to the address of the procedure being called within the new code segment.</p><p>Executing a task switch with the CALL instruction is similar to executing a call through a call gate. The target operand specifies the segment selector of the task gate for the new task activated by the switch (the offset in the target operand is ignored). The task gate in turn points to the TSS for the new task, which contains the segment selectors for the task’s code and stack segments. Note that the TSS also contains the EIP value for the next instruction that was to be executed before the calling task was suspended. This instruction pointer value is loaded into the EIP register to re-start the calling task.</p><p>The CALL instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 7, “Task Management,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for information on the mechanics of a task switch.</p><p>When you execute at task switch with a CALL instruction, the nested task flag (NT) is set in the EFLAGS register and the new TSS’s previous task link field is loaded with the old task’s TSS selector. Code is expected to suspend this nested task by executing an IRET instruction which, because the NT flag is set, automatically uses the previous task link to return to the calling task. (See “Task Linking” in Chapter 7 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for information on nested tasks.) Switching tasks with the CALL instruction differs in this regard from JMP instruction. JMP does not set the NT flag and therefore does not expect an IRET instruction to suspend the task.</p><p><strong>Mixing 16-Bit and 32-Bit Calls.</strong> When making far calls between 16-bit and 32-bit code segments, use a call gate. If the far call is from a 32-bit code segment to a 16-bit code segment, the call should be made from the first 64 KBytes of the 32-bit code segment. This is because the operand-size attribute of the instruction is set to 16, so only a 16-bit return address offset can be saved. Also, the call should be made using a 16-bit call gate so that 16-bit values can be pushed on the stack. See Chapter 21, “Mixing 16-Bit and 32-Bit Code,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B</em>, for more information.</p><p><strong>Far Calls in Compatibility Mode.</strong> When the processor is operating in compatibility mode, the CALL instruction can be used to perform the following types of far calls:</p><p>Note that a CALL instruction can not be used to cause a task switch in compatibility mode since task switches are not supported in IA-32e mode.</p><p>In compatibility mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine the type of call operation to be performed.</p><p>If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in compatibility mode is very similar to one carried out in protected mode. The target operand specifies an absolute far address either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register and the offset from the instruction is loaded into the EIP register. The difference is that 64-bit mode may be entered. This specified by the L bit in the new code segment descriptor.</p><p>Note that a 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. However, using this mechanism requires that the target code segment descriptor have the L bit set, causing an entry to 64-bit mode.</p><p>When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target</p><p>operand can specify the call gate segment selector either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)</p><p>On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a segment base of 0x0, the limit is ignored, and the default stack size is 64-bits. The full value of RSP is used for the offset, of which the upper 32-bits are undefined.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack and the segment selector and instruction pointer for the calling procedure’s code segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called within the new code segment.</p></article></section><section class="hidden-desktop" style="margin-top:3rem"><footer class="footer"><p>created by<!-- --> <a href="https://github.com/superhawk610" target="_blank">superhawk610</a> <!-- -->· <a href="https://github.com/superhawk610/x86reference">repo</a></p><p class="copyright">© <!-- -->2021<!-- -->, all rights reserved</p></footer></section></div></main></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/call";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-98a2719a671ef429ca89.js"],"app":["/app-78307e57dfe1c5aac904.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-a5772e129fd7c1580c64.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-d27ee753bf834a08cab1.js"],"component---src-templates-op-tsx":["/component---src-templates-op-tsx-e0141dc34b70c1c1eef2.js"]};/*]]>*/</script><script src="/x86reference/polyfill-98a2719a671ef429ca89.js" nomodule=""></script><script src="/x86reference/component---src-templates-op-tsx-e0141dc34b70c1c1eef2.js" async=""></script><script src="/x86reference/commons-c101e594ad3faaaa90f4.js" async=""></script><script src="/x86reference/app-78307e57dfe1c5aac904.js" async=""></script><script src="/x86reference/framework-240c1f9815d126e19dd9.js" async=""></script><script src="/x86reference/webpack-runtime-a3295d5c46c6b58c034e.js" async=""></script></body></html>
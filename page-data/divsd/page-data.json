{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/divsd",
    "result": {"pageContext":{"op":{"id":"divsd","variants":["VDIVSD","DIVSD"],"variant_descriptions":{"DIVSD":"Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/m64.","VDIVSD":"Divide low double-precision floating-point value in xmm2 by low double-precision floating-point value in xmm3/m64."},"text":"<p>Divides the low double-precision floating-point value in the first source operand by the low double-precision floating-point value in the second source operand, and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination are XMM registers.</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding ZMM destination register remain unchanged.</p><p>VEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The quadword at bits 127:64 of the destination operand is copied from the corresponding quadword of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.</p><p>EVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The quadword element of the destination operand at bits 127:64 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.</p><p>EVEX version: The low quadword element of the destination is updated according to the writemask.</p><p>Software should ensure VDIVSD is encoded with VEX.L=0. Encoding VDIVSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.</p>","href":"https://www.felixcloutier.com/x86/DIVSD.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/pclmulqdq",
    "result": {"pageContext":{"op":{"id":"pclmulqdq","variants":["PCLMULQDQ","VPCLMULQDQ"],"variant_descriptions":{"PCLMULQDQ":"Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.","VPCLMULQDQ":"Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used."},"text":"<p>Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use according to <a href=\"https://www.felixcloutier.com/x86/PCLMULQDQ.html#tbl-4-13\" rel=\"noreferrer noopener\" target=\"_blank\">Table 4-13</a>, other bits of the immediate byte are ignored.</p><p>The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.</p><p>Compilers and assemblers may implement the following pseudo-op syntax to simply programming and emit the required encoding for Imm8.</p>","href":"https://www.felixcloutier.com/x86/PCLMULQDQ.html"}}},
    "staticQueryHashes": ["3832154866","63159454"]}
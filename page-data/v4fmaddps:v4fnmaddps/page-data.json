{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/v4fmaddps:v4fnmaddps",
    "result": {"pageContext":{"op":{"id":"v4fmaddps:v4fnmaddps","variants":["V4FNMADDPS","V4FMADDPS"],"variant_descriptions":{"V4FMADDPS":"Multiply packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1.","V4FNMADDPS":"Multiply and negate packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1."},"text":"<p>This instruction computes 4 sequential packed fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.</p><p>In the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.</p><p>This instruction supports memory fault suppression. The entire memory operand is loaded if any of the 16 lowest significant mask bits is set to 1 or if a “no masking” encoding is used.</p><p>The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.</p><p>Rounding is performed at every FMA (fused multiply and add) boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc.</p>","href":"https://www.felixcloutier.com/x86/V4FMADDPS%3AV4FNMADDPS.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
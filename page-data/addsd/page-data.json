{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/addsd",
    "result": {"pageContext":{"op":{"id":"addsd","variants":["VADDSD","ADDSD"],"variant_descriptions":{"ADDSD":"Add the low double-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1.","VADDSD":"Add the low double-precision floating-point value from xmm3/m64 to xmm2 and store the result in xmm1 with writemask k1."},"text":"<p>Adds the low double-precision floating-point values from the second source operand and the first source operand and stores the double-precision floating-point result in the destination operand.</p><p>The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.</p><p>128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.</p><p>EVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.</p><p>EVEX version: The low quadword element of the destination is updated according to the writemask.</p><p>Software should ensure VADDSD is encoded with VEX.L=0. Encoding VADDSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.</p>","href":"https://www.felixcloutier.com/x86/ADDSD.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
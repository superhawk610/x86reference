{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/vp4dpwssd",
    "result": {"pageContext":{"op":{"id":"vp4dpwssd","variants":["VP4DPWSSD"],"variant_descriptions":{"VP4DPWSSD":"Multiply signed words from source register block indicated by zmm2 by signed words from m128 and accumulate resulting signed dwords in zmm1."},"text":"<p>This instruction computes 4 sequential register source-block dot-products of two signed word operands with doubleword accumulation; see <a href=\"https://www.felixcloutier.com/x86/VP4DPWSSD.html#fig-7-1\" rel=\"noreferrer noopener\" target=\"_blank\">Figure 7-1</a> below. The memory operand is sequentially selected in each of the four steps.</p><p>In the above box, the notation of “+3”' is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.</p><p>This instruction supports memory fault suppression. The entire memory operand is loaded if any bit of the lowest 16-bits of the mask is set to 1 or if a “no masking” encoding is used.</p><p>The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.</p>","href":"https://www.felixcloutier.com/x86/VP4DPWSSD.html"}}},
    "staticQueryHashes": ["3832154866","63159454"]}
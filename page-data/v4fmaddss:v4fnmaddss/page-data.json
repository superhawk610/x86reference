{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/v4fmaddss:v4fnmaddss",
    "result": {"pageContext":{"op":{"id":"v4fmaddss:v4fnmaddss","variants":["V4FNMADDSS","V4FMADDSS"],"variant_descriptions":{"V4FMADDSS":"Multiply scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1.","V4FNMADDSS":"Multiply and negate scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1."},"text":"<p>This instruction computes 4 sequential scalar fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.</p><p>In the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.</p><p>This instruction supports memory fault suppression. The entire memory operand is loaded if the least significant mask bit is set to 1 or if a “no masking” encoding is used.</p><p>The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.</p><p>Rounding is performed at every FMA boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc.</p>","href":"https://www.felixcloutier.com/x86/V4FMADDSS%3AV4FNMADDSS.html"}}},
    "staticQueryHashes": ["3832154866","63159454"]}
{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/phaddw:phaddd",
    "result": {"pageContext":{"op":{"id":"phaddw:phaddd","variants":["VPHADDD","VPHADDW","PHADDD","PHADDW"],"variant_descriptions":{"PHADDW":"Add 16-bit integers horizontally, pack to xmm1.","PHADDD":"Add 32-bit integers horizontally, pack to xmm1.","VPHADDW":"Add 16-bit signed integers horizontally, pack to ymm1.","VPHADDD":"Add 32-bit signed integers horizontally, pack to ymm1."},"text":"<p>(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><p>Note that these instructions can operate on either unsigned or signed (twoâ€™s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.</p><p>Legacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.</p><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: Horizontal addition of two adjacent data elements of the low 16-bytes of the first and second source operands are packed into the low 16-bytes of the destination operand. Horizontal addition of two adjacent data elements of the high 16-bytes of the first and second source operands are packed into the high 16-bytes of the destination operand. The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p><p>S7 S3 S3 S4 S3 S2 S1 S0</p>","href":"https://www.felixcloutier.com/x86/PHADDW%3APHADDD.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
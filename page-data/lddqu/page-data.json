{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/lddqu",
    "result": {"pageContext":{"op":{"id":"lddqu","variants":["VLDDQU","LDDQU"],"variant_descriptions":{"LDDQU":"Load unaligned data from mem and return double quadword in xmm1.","VLDDQU":"Load unaligned packed integer values from mem to ymm1."},"text":"<p>The instruction is <em>functionally similar</em> to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is: 32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched from memory and placed in a destination register (first operand). The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent.</p><p>This instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use (V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p>","href":"https://www.felixcloutier.com/x86/LDDQU.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
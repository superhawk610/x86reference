{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/adcx",
    "result": {"pageContext":{"op":{"id":"adcx","variants":["ADCX"],"variant_descriptions":{"ADCX":"Unsigned addition of r64 with CF, r/m64 to r64, writes CF."},"text":"<p>Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the unsigned addition of the operands.</p><p>The ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state. Often, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).</p><p>This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.</p><p>In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits.</p><p>ADCX executes normally either inside or outside a transaction region.</p><p>Note: ADCX defines the OF flag differently than the ADD/ADC instructions as defined in <em>Intel<sup>®</sup> 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A</em>.</p>","href":"https://www.felixcloutier.com/x86/ADCX.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
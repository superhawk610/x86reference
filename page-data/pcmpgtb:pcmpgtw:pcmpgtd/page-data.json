{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/pcmpgtb:pcmpgtw:pcmpgtd",
    "result": {"pageContext":{"op":{"id":"pcmpgtb:pcmpgtw:pcmpgtd","variants":["PCMPGTD","PCMPGTB","PCMPGTW","VPCMPGTD","VPCMPGTW","VPCMPGTB"],"variant_descriptions":{"PCMPGTB":"Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.","PCMPGTW":"Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.","PCMPGTD":"Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.","VPCMPGTB":"Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.","VPCMPGTW":"Compare packed signed word integers in ymm2 and ymm3/m256 for greater than.","VPCMPGTD":"Compare Greater between int32 elements in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask. k2."},"text":"<p>Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.</p><p>The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.</p><p>In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>EVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.</p><p>EVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.</p>","href":"https://www.felixcloutier.com/x86/PCMPGTB%3APCMPGTW%3APCMPGTD.html"}}},
    "staticQueryHashes": ["3832154866","63159454"]}
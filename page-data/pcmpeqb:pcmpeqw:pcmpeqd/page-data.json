{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/pcmpeqb:pcmpeqw:pcmpeqd",
    "result": {"pageContext":{"op":{"id":"pcmpeqb:pcmpeqw:pcmpeqd","variants":["VPCMPEQD","PCMPEQB","VPCMPEQB","VPCMPEQW","PCMPEQW","PCMPEQD"],"variant_descriptions":{"PCMPEQB":"Compare packed bytes in xmm2/m128 and xmm1 for equality.","PCMPEQW":"Compare packed words in xmm2/m128 and xmm1 for equality.","PCMPEQD":"Compare packed doublewords in xmm2/m128 and xmm1 for equality.","VPCMPEQB":"Compare packed bytes in xmm3/m128 and xmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.","VPCMPEQW":"Compare packed words in ymm3/m256 and ymm2 for equality.","VPCMPEQD":"Compare Equal between int32 vectors in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask k2."},"text":"<p>Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.</p><p>The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.</p><p>In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>EVEX encoded VPCMPEQD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.</p><p>EVEX encoded VPCMPEQB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.</p>","href":"https://www.felixcloutier.com/x86/PCMPEQB%3APCMPEQW%3APCMPEQD.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
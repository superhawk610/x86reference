{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/fyl2x",
    "result": {"pageContext":{"op":{"id":"fyl2x","variants":["FYL2X"],"variant_descriptions":{"FYL2X":"Replace ST(1) with (ST(1) ∗ log2ST(0)) and pop the register stack."},"text":"<p>Computes (ST(1) ∗ log<sub>2</sub> (ST(0))), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be a non-zero positive number.</p><p>The following table shows the results obtained when taking the log of various classes of numbers, assuming that neither overflow nor underflow occurs.</p><p>If the divide-by-zero exception is masked and register ST(0) contains ±0, the instruction returns ∞ with a sign that is the opposite of the sign of the source operand in register ST(1).</p><p>The FYL2X instruction is designed with a built-in multiplication to optimize the calculation of logarithms with an arbitrary positive base (b):</p><p>log<sub>b</sub>x ← (log<sub>2</sub>b)<sup>–1</sup> ∗ log<sub>2</sub>x</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p>","href":"https://www.felixcloutier.com/x86/FYL2X.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/popa:popad",
    "result": {"pageContext":{"op":{"id":"popa:popad","variants":["POPA","POPAD"],"variant_descriptions":{"POPA":"Pop DI, SI, BP, BX, DX, CX, and AX.","POPAD":"Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX."},"text":"<p>Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI, SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP register is incremented after each register is loaded.</p><p>The POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode. The POPA instruction is intended for use when the operand-size attribute is 16 and the POPAD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when POPA is used and to 32 when POPAD is used (using the operand-size override prefix [66H] if necessary). Others may treat these mnemonics as synonyms (POPA/POPAD) and use the current setting of the operand-size attribute to determine the size of values to be popped from the stack, regardless of the mnemonic used. (The D flag in the current code segmentâ€™s segment descriptor determines the operand-size attribute.)</p><p>This instruction executes as described in non-64-bit modes. It is not valid in 64-bit mode.</p>","href":"https://www.felixcloutier.com/x86/POPA%3APOPAD.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
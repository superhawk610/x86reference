{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/adox",
    "result": {"pageContext":{"op":{"id":"adox","variants":["ADOX"],"variant_descriptions":{"ADOX":"Unsigned addition of r64 with OF, r/m64 to r64, writes OF."},"text":"<p>Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands.</p><p>The ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).</p><p>This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.</p><p>In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.</p><p>ADOX executes normally either inside or outside a transaction region.</p><p>Note: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in <em>Intel<sup>®</sup> 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A</em>.</p>","href":"https://www.felixcloutier.com/x86/ADOX.html"}}},
    "staticQueryHashes": ["2451724630","3830446752","63159454"]}
{
    "componentChunkName": "component---src-templates-op-tsx",
    "path": "/vcvtph2ps",
    "result": {"pageContext":{"op":{"id":"vcvtph2ps","variants":["VCVTPH2PS"],"variant_descriptions":{"VCVTPH2PS":"Convert sixteen packed half precision (16-bit) floating-point values in ymm2/m256 to packed single-precision floating-point values in zmm1."},"text":"<p>Converts packed half precision (16-bits) floating-point values in the low-order bits of the source operand (the second operand) to packed single-precision floating-point values and writes the converted values into the destination operand (the first operand).</p><p>If case of a denormal operand, the correct normal result is returned. MXCSR.DAZ is ignored and is treated as if it 0. No denormal exception is reported on MXCSR.</p><p>VEX.128 version: The source operand is a XMM register or 64-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register are zeroed.</p><p>VEX.256 version: The source operand is a XMM register or 128-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.</p><p>EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register or a 256/128/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.</p><p>The diagram below illustrates how data is converted from four packed half precision (in 64 bits) to four single precision (in 128 bits) FP values.</p><p>Note: VEX.vvvv and EVEX.vvvv are reserved (must be 1111b).</p>","href":"https://www.felixcloutier.com/x86/VCVTPH2PS.html"}}},
    "staticQueryHashes": ["3832154866","63159454"]}